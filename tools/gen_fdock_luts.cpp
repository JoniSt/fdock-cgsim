#include <cmath>
#include <limits>
#include <iostream>
#include <iomanip>

#include "processligand_inline.h"

// This tool prints a C++ header with precomputed IntraE LUTs to stdout.
// Values are emitted as hex floats to guarantee bit-exact reproducibility.

namespace {
    static constexpr int    g_numDistanceIDs = 2048;
    static constexpr double g_distanceIDStep = 0.01;  // 0.01 .. 20.48
    static constexpr double g_desolvSigma    = 3.6;   // Must match runtime

    template<typename Fn>
    static void forEachDistanceID(Fn&& fn) {
        double dist = 0;
        for (int i = 0; i < g_numDistanceIDs; ++i) {
            dist += g_distanceIDStep;
            fn(i, dist);
        }
    }

    static void printArrayOpen(const char* name) {
        std::cout << "static constexpr double " << name << "[" << g_numDistanceIDs << "] = {\n";
    }

    static void printArrayClose() {
        std::cout << "};\n\n";
    }

    static void printHeaderPreamble() {
        std::cout << "#pragma once\n\n";
        std::cout << "// Auto-generated by gen_fdock_luts.\n";
        std::cout << "// Precomputed IntraE lookup tables as hex float constants.\n\n";
        std::cout << "namespace fdock_luts {\n\n";
    }

    static void printHeaderPostamble() {
        std::cout << "} // namespace fdock_luts\n";
    }

    template<typename Fn>
    static void printArray(const char* name, Fn&& compute) {
        printArrayOpen(name);
        forEachDistanceID([&](int i, double dist){
            const double v = compute(dist);
            std::cout << (i?", ":"  ") << v;
            if ((i % 4) == 3) std::cout << "\n";
        });
        std::cout << "\n";
        printArrayClose();
    }
}

int main() {
    // Ensure bit-exact float values
    std::cout << std::hexfloat;
    std::cout << std::setprecision(std::numeric_limits<double>::max_digits10);

    printHeaderPreamble();

    // r^(-6)
    printArray("intra_r_6_table", [](double dist){ return 1.0 / std::pow(dist, 6.0); });

    // r^(-10)
    printArray("intra_r_10_table", [](double dist){ return 1.0 / std::pow(dist, 10.0); });

    // r^(-12)
    printArray("intra_r_12_table", [](double dist){ return 1.0 / std::pow(dist, 12.0); });

    // r * eps_r(dist), unscaled
    printArray("intra_r_epsr_table_unscaled", [](double dist){
        const double epsr = calc_ddd_Mehler_Solmajer(dist);
        return dist * epsr;
    });

    // desolvation Gaussian: exp(-dist^2 / (2*sigma^2)), unscaled
    const double twoSigma2 = 2.0 * g_desolvSigma * g_desolvSigma;
    printArray("intra_desolv_table_unscaled", [twoSigma2](double dist){
        return std::exp(- (dist * dist) / twoSigma2);
    });

    printHeaderPostamble();
    return 0;
}
